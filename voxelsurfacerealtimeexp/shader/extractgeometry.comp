#version 430

#include "constantbuffers.glsl"
#include "sparseVoxelOctree.glsl"


// output buffer
layout(binding = 0, offset = 0) uniform atomic_uint NumQuadsAtomicCounter; // output buffer size, this is part of a draw indirect buffer
layout(binding = 1) writeonly buffer QuadBuffer
{
	uint Quads[];	// 8bit xyz position, 8bit w quad identifier
};

shared float volumeCache[1000]; 

// compute shader size
layout (local_size_x = 10, local_size_y = 10, local_size_z = 10) in;
void main()
{
	ivec3 volumeCoordinate = ivec3(gl_WorkGroupID.xyz) * ivec3(8,8,8) + ivec3(gl_LocalInvocationID.xyz) - ivec3(1,1,1);
	uint volumeCachePos = gl_LocalInvocationID.x + gl_LocalInvocationID.y*10 + gl_LocalInvocationID.z*100;

	// fill shared memory
	uvec3 volumeSamplingPos = uvec3(clamp(volumeCoordinate, ivec3(0), VolumeMaxLoadCoord));
	float ownValue = SampleOctree(volumeSamplingPos);
	
	volumeCache[volumeCachePos] = ownValue ;

	// early outs
	// own iso to small
	if(ownValue <= 0.0f)
		return;
	// border threads (useless now)
	if(any(equal(gl_LocalInvocationID.xyz, uvec3(0))) || 
	   any(equal(gl_LocalInvocationID.xyz, uvec3(9))) )
		return;

	 // sync
	barrier();

	// watch sourrundings
	bool left     = volumeCache[volumeCachePos - 1] > 0.0f;
	bool right    = volumeCache[volumeCachePos + 1] > 0.0f;
	bool up       = volumeCache[volumeCachePos + 10] > 0.0f;
	bool down     = volumeCache[volumeCachePos - 10] > 0.0f;
	bool forward  = volumeCache[volumeCachePos + 100] > 0.0f;
	bool backward = volumeCache[volumeCachePos - 100] > 0.0f;

	// all of them? so this one is useless
	if(left && right && up && down && forward && backward)
		return;

	uint quadData;
	quadData = volumeCoordinate.x | (volumeCoordinate.y << 8) | (volumeCoordinate.z << 16);
	uint quadIndex;
	if(!up)
	{
		quadIndex = atomicCounterIncrement(NumQuadsAtomicCounter);
		Quads[quadIndex] = quadData;// | (uint(0) << 24);
	}
	if(!down)
	{
		quadIndex = atomicCounterIncrement(NumQuadsAtomicCounter);
		Quads[quadIndex] = quadData | (uint(1) << 24);
	}
	if(!left)
	{
		quadIndex = atomicCounterIncrement(NumQuadsAtomicCounter);
		Quads[quadIndex] = quadData | (uint(2) << 24);
	}
	if(!right)
	{
		quadIndex = atomicCounterIncrement(NumQuadsAtomicCounter);
		Quads[quadIndex] = quadData | (uint(3) << 24);
	}
	if(!forward)
	{
		quadIndex = atomicCounterIncrement(NumQuadsAtomicCounter);
		Quads[quadIndex] = quadData | (uint(4) << 24);
	}
	if(!backward)
	{
		quadIndex = atomicCounterIncrement(NumQuadsAtomicCounter);
		Quads[quadIndex] = quadData | (uint(5) << 24);
	}
}
